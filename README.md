.NET Core Employee Management System APIThis project implements a backend module for an ERP-style Employee Management System using ASP.NET Core Web API, adhering to Clean Architecture principles.Task ObjectiveThe objective was to build a robust, maintainable, and scalable backend API for employee and department management, including log history tracking, advanced filtering/sorting, and proper architectural patterns.Architecture & Folder StructureThis solution is built following a Clean Architecture (also known as Layered Architecture with strict dependency rules) to ensure separation of concerns, testability, and maintainability.The solution is divided into the following projects/layers:Backend developer Case Study (Presentation Layer / API)This is the entry point of the application.Contains ASP.NET Core Web API controllers (Controllers folder).Handles HTTP requests, model binding, and returns API responses.Configures Dependency Injection for all layers.Integrates Swagger for API documentation and testing.Dependencies: EmployeeManagement.Services, EmployeeManagement.Infrastructure, EmployeeManagement.Domain.EmployeeManagement.Services (Application Layer)Contains the application-specific business logic and use cases.Orchestrates operations using domain entities and repository interfaces.Performs DTO mapping and server-side validation.Dependencies: EmployeeManagement.Domain (via interfaces).EmployeeManagement.Domain (Domain Layer / Core)The innermost layer, representing the core business rules and entities.Contains Entities (e.g., Employee, Department, LogHistory).Defines Interfaces for repositories and the Unit of Work.Dependencies: None (it is independent).EmployeeManagement.Infrastructure (Infrastructure Layer)Responsible for data persistence and external concerns.Contains Data (e.g., AppDbContext, AppDbContextFactory).Contains Configurations for Entity Framework Core Fluent API mappings.Contains concrete Repositories implementations (e.g., EmployeeRepository, DepartmentRepository, LogHistoryRepository).Implements the UnitOfWork pattern.Dependencies: EmployeeManagement.Domain.Setup Instructions (How to Run the Project)Prerequisites:.NET SDK (e.g., .NET 8.0)Visual Studio (2022 recommended)SQL Server (or SQL Server Express / LocalDB)Clone the Repository / Unzip the Solution:git clone [Your-GitHub-Repo-URL]
cd "Backend developer Case Study"
(Or simply unzip the provided solution file).Open in Visual Studio:Open the Backend developer Case Study.sln file in Visual Studio.Restore NuGet Packages:Visual Studio should automatically prompt you to restore NuGet packages. If not, right-click on the Solution in Solution Explorer and select "Restore NuGet Packages".Configure Database Connection String:Open Backend developer Case Study/appsettings.json (and appsettings.Development.json).Ensure the DefaultConnection string points to your local SQL Server instance. The current configuration uses LocalDB with Windows Authentication:"ConnectionStrings": {
  "DefaultConnection": "Server=.;Database=EmployeeManagementDb;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=True"
}
Note: Server=. refers to the default local SQL Server instance. If you use a different instance name (e.g., (localdb)\mssqllocaldb), update it accordingly. TrustServerCertificate=True is included for development environments to bypass SSL certificate validation.Apply Database Migrations:Open Package Manager Console in Visual Studio (Tools > NuGet Package Manager > Package Manager Console).Set "Default project" to EmployeeManagement.Infrastructure.Run the following command to apply the initial database schema:Update-Database
(If this is the first time, you might need to run Add-Migration InitialCreate first, but the InitialCreate migration file is already provided).Run the Application:Set Backend developer Case Study as the Startup Project (Right-click solution > Set Startup Projects...).Press F5 or click "Debug" > "Start Debugging" in Visual Studio.Your browser should open to the Swagger UI (typically at https://localhost:XXXX/swagger/index.html).API Endpoints (via Swagger)Once the application is running, you can interact with the API using the Swagger UI.Employee Management (/api/Employees)GET /api/Employees: Retrieve a list of employees with optional filters, sorting, and pagination.Filters: name, departmentId, status (0=Active, 1=Suspended), hireDateStart, hireDateEnd.Sorting: sortBy ("Name", "HireDate"), sortOrder ("asc", "desc").Pagination: pageNumber, pageSize.GET /api/Employees/{id}: Retrieve a single employee by ID.POST /api/Employees: Create a new employee.Request Body Example:{
  "name": "Jane Smith",
  "email": "jane.smith@example.com",
  "departmentId": 1
}
PUT /api/Employees/{id}: Update an existing employee.Request Body Example (partial update):{
  "name": "Jane Smith Updated",
  "status": 1 // Suspended
}
DELETE /api/Employees/{id}: Delete an employee by ID.Department Management (/api/Departments)GET /api/Departments: Retrieve all departments.GET /api/Departments/{id}: Retrieve a single department by ID.POST /api/Departments: Create a new department.Request Body Example:{
  "name": "Human Resources"
}
Log History Tracking (/api/LogHistory)GET /api/LogHistory: Retrieve all log entries.GET /api/LogHistory?employeeId={id}: Retrieve log entries filtered by a specific employee ID.Validation and Error HandlingServer-Side Validation: Implemented using Data Annotations on DTOs (e.g., [Required], [EmailAddress]) and explicit checks in service layer (e.g., unique email, department existence).Clear Error Messages: API returns 400 Bad Request for model validation errors, 404 Not Found for non-existent resources, and 409 Conflict for business rule violations (e.g., duplicate email/department name, non-existent department ID).Assumptions MadeDatabase: Assumed SQL Server (LocalDB for development) as the database system.Authentication/Authorization: Not implemented as per the core task scope.Logging Details: Simple Console.WriteLine used for internal service-level errors/validation messages. In a production environment, a proper logging framework (e.g., Serilog, NLog) would be integrated.Error Handling Granularity: For simplicity, service methods return null on validation/business rule failures, and controllers translate this into generic 409 Conflict or 404 Not Found. In a more complex application, services might return custom Result objects for more detailed error information.EmployeeStatus Enum: Mapped to string in the database for readability.HireDate: Automatically set to DateTime.UtcNow upon employee creation.
